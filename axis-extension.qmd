---
title: "axis-extension"
format: html
editor: visual

params: 
  eval_models: true
    
execute:
  echo: false
  warning: true
  message: true
  include: false
---

```{r}
#| label: load-packages
library(tidyverse)
library(lme4)
library(buildmer)
library(qwraps2)
library(emmeans)
library(broom.mixed)
library(effectsize)
library(papaja)
```

```{r}
#| label: lazyload-cache
if (!params$eval_models){
lazyload_cache_dir('axis-extension_cache/html')}
```

```{r}
#| label: wrangle
anon_data1 <- read_csv('data/anon_data1.csv',
                       col_types = cols(.default = "?", genderResp2.text = col_character()))
# correct the coercion of the genderResp2.text to logical

anon_data2 <- read_csv('data/anon_data2.csv')

# perform necessary data wrangling
wrangle <- function(anon_file, .y) {
  # .y captures the index of the file in the list supplied to iwalk

# extract literacy data
# calculate literacy score (sum of five responses)
literacy <- anon_file %>%
  filter(!is.na(q1_slider.response)) %>%
  rowwise() %>%
  mutate(literacy = sum(c(q1_slider.response, 
                          q2_slider.response, 
                          q3_slider.response, 
                          q4_slider.response, 
                          q5_slider.response))) %>%
  select(participant,
         literacy)

# define education categories 
edu_labels <- set_names(c('No formal qualications',
                          'Secondary education (e.g. GED/GCSE)',
                          'High school diploma/A-levels',
                          'Technical/community college',
                          'Undergraduate degree (BA/BSc/other)',
                          'Graduate degree (MA/MSc/MPhil/other)',
                          'Doctorate degree (PhD/other)',
                          'Don\'t know / not applicable'),
                        seq(8,1,-1))

# define gender categories
gender_labels <- set_names(c("Prefer not to say", 
                             "In another way:",
                             "Non-binary", 
                             "Man", 
                             "Woman"),
                           1:5)
# extract demographics
# link slider response numbers to gender categories 
# link slider response numbers to education categories
demographics <- anon_file %>%
  filter(!is.na(genderResp1.response)) %>%
  mutate(genderResp1.response = 
           recode(genderResp1.response, !!!gender_labels)) %>%
  mutate(edu_slider.response =
           recode(edu_slider.response, !!!edu_labels)) %>%
  select(participant,
         ageResp.text,
         genderResp1.response,
         edu_slider.response)

# extract duration data (in seconds)
durations <- anon_file %>%
  filter(!is.na(total_duration)) %>%
  select(participant, total_duration)
  
# select relevant columns
# select only experimental items
# add literacy and demographic data
# change data types where appropriate
# output this file with suffix 'tidy'
anon_file %>% 
  filter(item_type == "E") %>%
  select(matches(c("participant",
                   "item_no",
                   "item_type",
                   "cond",
                   "axis",
                   "denominator",
                   "slider.response",
                   "mag_slider.response",
                   "con_slider.response"))) %>% 
    inner_join(literacy, by = "participant") %>%
    inner_join(demographics, by = "participant") %>%
    inner_join(durations, by = "participant") %>%
    mutate(total_duration = total_duration / 60) %>%
    mutate(across(matches(c("axis", "denominator", "cond")), as_factor)) %>%
    mutate(across(c("participant", "item_no"), as.character)) %>%
    assign(paste0("e", .y),
           value = ., envir = .GlobalEnv)
}

iwalk(list(anon_data1, anon_data2), wrangle)


# set sum contrasts
contrasts(e2$axis) <- contr.sum(2)
contrasts(e2$denominator) <- contr.sum(2)
```

```{r}
#| label: comparison-function
# this function takes a model and creates a new model for anova comparison
# a new set of fixed effects will be specified, but the same random effects structure will be used
comparison <- function(model, fixed) {
  
  form <- formula(model)
  
  newfixed <- function(form, fixed) {

    fixedfx <-
      remove.terms(form,"placeholder") %>% # generate full formula (expand '*')
      nobars() # get formula for fixed effects only

    fixedterms <-
      terms.formula(fixedfx) %>% # get terms for fixed effects
      attr("term.labels") # get character vector of fixed effects terms

    # remove all terms to get only the response
    response <- remove.terms(fixedfx, fixedterms) %>% remove.terms(fixedterms)

    out <- add.terms(response, fixed)
    return(out)
  }
  
  getrandom <- function(form) {
    
    parens <- function(x) {paste0("(",x,")")}
    onlyBars <- function(form) {
      reformulate(
        sapply(
          findbars(form), # list of character vector for each random effect
          function(x)  parens(deparse(x))), # put each character vector in brackets
        response = form[[2]]) 
    }
    
    out <- onlyBars(form)
    return(out)
  }
  
  merge.formula <- function(form1, form2, ...){
    # adapted from https://stevencarlislewalker.wordpress.com/2012/08/06/merging-combining-adding-together-two-formula-objects-in-r/
    
    # get character strings of the names for the responses 
    # (i.e. left hand sides, lhs)
    lhs1 <- deparse(form1[[2]])
    #print(lhs1)
    lhs2 <- deparse(form2[[2]])
    #print(lhs2)
    if(lhs1 != lhs2) stop('both formulas must have the same response')
    
    # get character strings of the right hand sides
    rhs1 <- strsplit(paste(form1[3]), " \\+ ")[[1]] 
    rhs2 <- strsplit(paste(form2[3]), " \\+ ")[[1]] 
    
    # put the two sides together with the amazing 
    # reformulate function
    out <- reformulate(termlabels = c(rhs1, rhs2), 
                       response = lhs1)
    
    # set the environment of the formula (i.e. where should
    # R look for variables when data aren't specified?)
    #environment(out) <- parent.frame()
    return(out)
  }
  
  newfixedfx <- newfixed(form, fixed)
  fullranfx <- getrandom(form)
  merge.formula(newfixedfx, fullranfx)
  
}
```

```{r}
#| label: anova-results-function
# this function takes two nested models, runs an anova, and the outputs the Likelihood Ratio Statistic, degrees of freedom, and p value to the global environment
anova_results <- function(test_model, full_model) {
  
  # first argument 
  test_model_name <- deparse(substitute(test_model))
  full_model_name <- deparse(substitute(full_model))

  if (class(test_model) == "buildmer") test_model <- test_model@model
  if (class(full_model) == "buildmer") full_model <- full_model@model
  
  anova_output <- anova(test_model, full_model)
  
  assign(paste0(test_model_name, ".Chi"),
         anova_output$Chisq[2],
         envir = .GlobalEnv)
  assign(paste0(test_model_name, ".Df"),
         anova_output$Df[2],
         envir = .GlobalEnv)
  assign(paste0(test_model_name, ".p"),
         anova_output$`Pr(>Chisq)`[2],
         envir = .GlobalEnv)
  
  es <- eta_squared(anova(full_model), partial = TRUE) 
  
  es %>% pull(Parameter) %>%
    map(function(x) assign(paste0(full_model_name, 
                                  ".eta.", 
                                  str_replace(x, ":", "_")),
                           es %>%
                             filter(Parameter == x) %>% 
                             pull(Eta2_partial),
                           envir = .GlobalEnv))
}
```

```{r}
#| label: get-contrasts-function

get_contrasts <- function(contrast_df, condition) {
  
  extract_vals <- function(one_row, param) {
    assign(value = (one_row %>% pull(param)),
           envir = .GlobalEnv,
           paste0(df_name,
                  ".",
                  (one_row %>% pull(!!sym(condition))),
                  ".",
                  param))
    }

  rows <- contrast_df %>% 
    contrast("consec", 
             simple = "each", 
             combine = TRUE, 
             adjust = "sidak") %>%
    as_tibble() %>% 
    filter(!!sym(condition) != ".") %>%
    group_split(!!sym(condition)) 
  
  params <- c("estimate", "SE", "df", "z.ratio", "p.value")
  
  df_name <- deparse(substitute(contrast_df))
  
  combinations <- expand_grid(rows, params)
  pmap(combinations, ~extract_vals(..1, ..2))
}
```

```{r}
#| label: random-str-function

# this function creates a table which displays the random effects structure (intercepts and slopes) for a given model
random_str <- function(model) {
  model <- model@model
  terms <- model %>% find_random %>% unlist() %>% unname()
  mylist <- model %>% formula %>% findbars() %>% as.character()
  slopes <- lapply(mylist, str_extract, "(?<=\\+ )(.*)(?= \\| )") %>% 
    unlist()
  tibble(terms, slopes)
}
```

```{r}
#| label: print-es-function
# for dealing with effect sizes less than .001
print_es <- function(x) {ifelse(x<.01, "< 0.01", paste("=", printnum(x)))}
```

## Experiment 1 - Analysis

```{r}
#| include: true
e1 %>%
  ggplot(aes(x = slider.response, y = cond)) +
  geom_jitter(width = 0,
              height = 0.2,
              alpha = 0.1) +
  scale_y_discrete(breaks = c("full", "trunc"),
                   labels = c("Extended", "Truncated")) + 
  labs(title = 'Experiment 1',
      y = NULL,
       x = NULL) + 
  scale_x_continuous(labels = c('Very low\nmagnitude', 'Very high\nmagnitude'),
    breaks = c(1,2),
    minor_breaks = c()) + 
  theme_minimal()
```

```{r}
#| label: e1-mag
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e1_mag <- buildmer(slider.response ~ cond +
                     (1 + cond | participant) + 
                     (1 + cond | item_no),
                   data = e1)
```

```{r}
#| label: e1-mag-cmpr
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e1_mag_cmpr <- lmer(comparison(e1_mag, fixed = NULL), 
                        data = e1)
```

```{r}
#| label: e1-mag-anova

anova_results(e1_mag_cmpr, e1_mag)
```

There was a significant effect of axis upper bound: $\chi^2$(`r in_paren(e1_mag_cmpr.Df)`) = `r printnum(e1_mag_cmpr.Chi)`, p `r printp(e1_mag_cmpr.p, add_equals = TRUE)`, partial $\eta^2$ = `r printnum(e1_mag.eta.cond)`. Participants awarded higher ratings to charts with truncated axes, compared to charts with extended axes.

## Experiment 2 - Analysis

### Magnitude Ratings

```{r}
#| label: fig-e2-mag
#| include: true

denom_labs <- c("Denominator Present in Text", 
                 "Denominator Absent from Text")
names(denom_labs) <- c("pres", "abs")

e2 %>%
  ggplot(aes(x = mag_slider.response, y = axis)) +
  geom_jitter(width = 0,
              height = 0.2,
              alpha = 0.1) +
  scale_y_discrete(breaks = c("full", "trunc"),
                   labels = c("Extended", "Truncated")) + 
  labs(title = 'Experiment 2',
      y = NULL,
       x = NULL) + 
  scale_x_continuous(labels = c('Very low\nmagnitude', 'Very high\nmagnitude'),
    breaks = c(1,2),
    minor_breaks = c()) + 
  facet_wrap(vars(denominator), ncol = 1, labeller = labeller(denominator = denom_labs)) +
  theme_minimal()
  
```

@fig-e2-mag shows the raw data.

```{r}
#| label: e2-mag
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e2_mag <- buildmer(mag_slider.response ~ axis*denominator +
                     (1 + axis*denominator | participant) + 
                     (1 + axis*denominator | item_no),
                   data = e2)
```

```{r}
#| label: e2-mag-cmpr
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e2_mag_test_int <- lmer(comparison(e2_mag, 
                                   fixed = "axis + denominator"), 
                        data = e2)
e2_mag_test_denom <- lmer(comparison(e2_mag, 
                                     fixed = "axis + axis:denominator"), 
                          data = e2)
e2_mag_test_axis <- lmer(comparison(e2_mag, 
                                    fixed = "denominator + axis:denominator"),
                         data = e2)

```

```{r}
#| label: e2-mag-anova

anova_results(e2_mag_test_int, e2_mag)
anova_results(e2_mag_test_denom, e2_mag)
anova_results(e2_mag_test_axis, e2_mag)

```

```{r}
#| label: e2-mag-contrasts

e2_mag_emm <- emmeans(e2_mag@model, pairwise ~ axis * denominator, adjust = 'sidak') 
  
get_contrasts(e2_mag_emm, condition = "denominator")

emmip(e2_mag@model, denominator ~ axis, CIs = T) +
  scale_x_discrete(labels = c('Absent from text', 'Present in text')) +
  scale_color_discrete(labels = c('Truncated', 'Extended'))
```

For magnitude ratings, likelihood ratio tests revealed main effects for both axis upper bound ($\chi^2$(`r in_paren(e2_mag_test_axis.Df)`) = `r printnum(e2_mag_test_axis.Chi)`, p `r printp(e2_mag_test_axis.p, add_equals = TRUE)`, partial $\eta^2$ = `r printnum(e2_mag.eta.axis)`) and denominator presence ($\chi^2$(`r in_paren(e2_mag_test_denom.Df)`) = `r printnum(e2_mag_test_denom.Chi)`, p `r printp(e2_mag_test_denom.p, add_equals = TRUE)`, partial $\eta^2$ = `r printnum(e2_mag.eta.denominator)`).

There was also a significant interaction between axis upper bound and denominator information: $\chi^2$(`r in_paren(e2_mag_test_int.Df)`) = `r printnum(e2_mag_test_int.Chi)`, p `r printp(e2_mag_test_int.p, add_equals = TRUE)`, partial $\eta^2$ = `r printnum(e2_mag.eta.axis_denominator)`.

Pairwise comparisons reveal that charts with extended and truncated axes were rated differently when the denominator was present, replicating the effect from E1 (z = `r printnum(e2_mag_emm.pres.z.ratio)`, p `r printp(e2_mag_emm.pres.p.value, add_equals = TRUE)`), and also when the denominator was absent (`r printnum(e2_mag_emm.abs.z.ratio)`, `r printp(e2_mag_emm.abs.p.value)`). Therefore, the interaction indicates that the degree of difference in magnitude ratings was affected by whether the denominator was present or absent.

This model employed by-participant and by-item random effects. For each participant, there were random intercepts, plus random slopes for axis upper bounds and denominator presence. For each item, there were random intercepts, plus random slopes for denominator presence.

```{r}
formula(e2_mag@model)
```

### Confidence Ratings

```{r}
#| label: e2-con-plot
#| include: true

denom_labs <- c("Denominator Present in Text", 
                 "Denominator Absent from Text")
names(denom_labs) <- c("pres", "abs")

e2 %>%
  ggplot(aes(x = con_slider.response, y = axis)) +
  geom_jitter(width = 0,
              height = 0.2,
              alpha = 0.1) +
  scale_y_discrete(breaks = c("full", "trunc"),
                   labels = c("Extended", "Truncated")) + 
  labs(title = 'Experiment 2',
      y = NULL,
       x = NULL) + 
  scale_x_continuous(labels = c('Not very\nconfident', 'Very\nconfident'),
    breaks = c(1,2),
    minor_breaks = c()) + 
  facet_wrap(vars(denominator), ncol = 1, labeller = labeller(denominator = denom_labs)) +
  theme_minimal()
  
```

@fig-e2-con shows the raw data.

```{r}
#| label: e2-con
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e2_con <- buildmer(con_slider.response ~ axis*denominator +
                     (1 + axis*denominator | participant) + 
                     (1 + axis*denominator | item_no),
                   data = e2)
```

```{r}
#| label: e2-con-cmpr
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e2_con_cmpr <- lmer(comparison(e2_con,
                               fixed = "axis + denominator"), 
                        data = e2)
```

```{r}
#| label: e2-con-anova

anova_results(e2_con_cmpr, e2_con)

e2_con_summ <- anova(e2_con) %>% as_tibble(rownames = "FixEf", .name_repair = make.names) %>%
  rename("Pr" = "Pr..F.")
```

There was also a significant interaction between axis upper bound and denominator information: $\chi^2$(`r in_paren(e2_con_cmpr.Df)`) = `r printnum(e2_con_cmpr.Chi)`, p `r printp(e2_con_cmpr.p, add_equals = TRUE)`, partial $\eta^2$ = `r printnum(e2_con.eta.denominator_axis)`.

There was a significant difference at different levels of axis: F = `r printnum(e2_con_summ %>% filter(FixEf == 'axis') %>% pull(F.value))`, p `r printp(e2_con_summ %>% filter(FixEf == 'axis') %>% pull(Pr), add_equals = T)`.

and at different levels of denominator: `r printnum(e2_con_summ %>% filter(FixEf == 'denominator') %>% pull(F.value))`, p `r printp(e2_con_summ %>% filter(FixEf == 'denominator') %>% pull(Pr), add_equals = T)`.

```{r}
#| label: e2-con-contrasts

e2_con_emm <- emmeans(e2_con@model, pairwise ~ axis * denominator, adjust = 'sidak') 
  
get_contrasts(e2_con_emm, condition = "denominator")
```

```{r}
#| include: true
formula(e2_con@model)
```

```{r}
#| include: true
emmip(e2_con@model, axis ~ denominator, CIs = T) +
  scale_x_discrete(labels = c('Absent from text', 'Present in text')) +
  scale_color_discrete(labels = c('Truncated', 'Extended'))
```

```{r}
knitr::knit_exit()
```

# Magnitude Ratings and Data Visualisation Literacy

```{r}
#| label: e2-lit
#| eval: !expr params$eval_models
#| cache: !expr params$eval_models

e2_mag_l <- lmer(add.terms(formula(e2_mag),
"literacy"),
              data = e2)
e2_con_l <- lmer(add.terms(formula(e2_con),
"literacy"),
              data = e2)
```

```{r}
#| label: e2-lit-results

summary_extract(e2_mag_l, "axis1:denominator1")
summary_extract(e2_con_l, "denominator1:axis1")

```
